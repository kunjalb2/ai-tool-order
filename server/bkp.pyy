"""
FastAPI Backend with SSE for AI Agent - Frontend Integration
================================================================
Matches React frontend expectations for:
- SSE events (/api/events)
- Chat API (/api/chat)
- Approval API (/api/approval)
- Database integration for users and orders
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional, Dict, AsyncGenerator
import asyncio
import json
import os
import random
import string
from openai import OpenAI
from dotenv import load_dotenv
import uuid
from datetime import datetime

# Database imports
from database import engine, SessionLocal, User, Order, get_db, send_verification_email
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.orm.attributes import flag_modified

load_dotenv()

app = FastAPI()

# ============================================================================
# CORS Configuration
# ============================================================================

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================================
# OpenAI Setup
# ============================================================================

client = OpenAI(
    base_url="https://openrouter.ai/api/v1",
    api_key=os.getenv("OPENROUTER_API_KEY"),
)

MODEL = "x-ai/grok-code-fast-1"

# ============================================================================
# Session Management
# ============================================================================


class SessionManager:
    def __init__(self):
        # In-memory storage only for event queues (SSE streams)
        # Session data is not persisted, only event queues are kept
        self.event_queues: Dict[str, asyncio.Queue] = {}
        # Keep in-memory history and pending_approval for active sessions
        # These are not persisted to database
        self.sessions: Dict[str, Dict] = {}

    def create_session(self, current_user: Optional[Dict[str, str]] = None) -> str:
        """Create a new session with optional user information"""
        session_id = str(uuid.uuid4())

        # Build session data
        session_data = {
            "history": [],
            "pending_approval": None,
            "current_response": "",
        }

        # Add user info if provided
        if current_user:
            user_id = current_user.get("id")
            if user_id:
                # Fetch user from database
                db: Session = SessionLocal()
                try:
                    user = db.query(User).filter(User.id == user_id).first()
                    if user:
                        session_data["user_id"] = user.id
                        session_data["user_name"] = user.name
                        session_data["user_email"] = user.email
                        print(f"DEBUG: Created session {session_id} for user {user.id} ({user.email})")
                    else:
                        print(f"DEBUG: User {user_id} not found in database")
                finally:
                    db.close()

        self.sessions[session_id] = session_data
        self.event_queues[session_id] = asyncio.Queue()
        return session_id

    def get_session(self, session_id: str) -> Optional[Dict]:
        """Get session data from in-memory storage"""
        return self.sessions.get(session_id)

    def get_event_queue(self, session_id: str) -> Optional[asyncio.Queue]:
        """Get event queue for SSE streaming"""
        return self.event_queues.get(session_id)

    def get_or_create_event_queue(self, session_id: str) -> asyncio.Queue:
        """Get existing event queue or create a new one for the session"""
        if session_id not in self.event_queues:
            print(f"DEBUG: Creating new event queue for existing session {session_id}")
            self.event_queues[session_id] = asyncio.Queue()
        return self.event_queues[session_id]

    async def emit_event(self, session_id: str, event_type: str, data: dict):
        """Emit an event to the SSE stream"""
        queue = self.get_event_queue(session_id)
        if queue:
            event = {"type": event_type, "data": data}
            print(f"DEBUG: Emitting event to session {session_id}: {event_type}")
            await queue.put(event)
        else:
            print(f"DEBUG: No queue found for session {session_id}, cannot emit event {event_type}")

    def cleanup_session(self, session_id: str):
        """Clean up session data and event queue from memory"""
        if session_id in self.sessions:
            del self.sessions[session_id]
        if session_id in self.event_queues:
            del self.event_queues[session_id]


session_manager = SessionManager()

# ============================================================================
# Database Helper Functions
# ============================================================================

def get_order_status(db: Session, order_id: str, current_user: Optional[Dict[str, str]] = None) -> dict:
    """Get order status by order ID from database"""
    try:
        # Query order with user join
        order = db.query(Order).options(
            joinedload(Order.user)
        ).filter(Order.order_id == order_id).first()

        if not order:
            return {"success": False, "error": "Order not found"}

        # Check if order belongs to current user if provided
        if current_user and current_user.get("id"):
            user_id = current_user.get("id")
            if order.user_id != user_id:
                return {"success": False, "error": "Order not found"}

        # Build response data
        order_data = {
            "order_id": order.order_id,
            "customer": order.customer_name,
            "status": order.status,
            "items": order.items,
            "total": order.total,
            "date": order.date.strftime("%Y-%m-%d") if order.date else None,
            "user_email": order.user.email if order.user else None,
            "user_name": order.user.name if order.user else None,
        }

        print(f"DEBUG: Retrieved order {order_id} for user {order.user_id}")
        return {"success": True, "order": order_data}

    except Exception as e:
        print(f"Error fetching order status: {e}")
        return {"success": False, "error": "Database error"}


def generate_cancellation_code(db: Session, order_id: str, current_user: Optional[Dict[str, str]] = None) -> dict:
    """Generate verification code for cancellation from database"""
    try:
        # Query order with user join
        order = db.query(Order).options(
            joinedload(Order.user)
        ).filter(Order.order_id == order_id).first()

        if not order:
            return {"success": False, "error": "Order not found"}

        # Check if order belongs to current user if provided
        if current_user and current_user.get("id"):
            user_id = current_user.get("id")
            if order.user_id != user_id:
                return {"success": False, "error": "Order not found"}

        # Check if order is already cancelled
        if order.status == "cancelled":
            return {"success": False, "error": "This order has already been cancelled and cannot be cancelled again"}

        # Check if order can be cancelled (only processing or shipped orders can be cancelled)
        cancellable_statuses = ["processing", "shipped"]
        if order.status not in cancellable_statuses:
            return {"success": False, "error": f"This order cannot be cancelled because its status is '{order.status}'. Only orders with status 'processing' or 'shipped' can be cancelled"}

        # Get user email for sending email
        user_email = order.user.email if order.user else None
        user_name = order.user.name if order.user else order.customer_name

        # Generate verification code
        code = "".join(random.choices(string.digits, k=6))

        # Initialize verification_codes list if None
        if order.verification_codes is None:
            order.verification_codes = []

        # Add code to order's verification_codes
        order.verification_codes.append(code)

        # Flag the JSON column as modified (required for SQLAlchemy JSON columns)
        flag_modified(order, "verification_codes")

        db.commit()
        db.refresh(order)

        print(f"DEBUG: Stored verification code {code} in DB for order {order_id}, verification_codes now: {order.verification_codes}")

        # Send verification email
        if user_email:
            send_verification_email(order_id, code, user_email, user_name)

        print(f"DEBUG: Generated verification code for order {order_id}")

        return {
            "success": True,
            "message": "Verification code generated",
            "code": code,
            "order_id": order_id,
            "requires_approval": True,
            "user_email": user_email,
            "user_name": user_name,
            "customer": order.customer_name,
        }

    except Exception as e:
        print(f"Error generating cancellation code: {e}")
        return {"success": False, "error": "Database error"}


def cancel_order_with_verification(db: Session, order_id: str, verification_code: str, current_user: Optional[Dict[str, str]] = None) -> dict:
    """Cancel order with verification code from database"""
    try:
        # Query order with user join
        order = db.query(Order).options(
            joinedload(Order.user)
        ).filter(Order.order_id == order_id).first()

        if not order:
            return {"success": False, "error": "Order not found"}

        # Check if order belongs to current user if provided
        if current_user and current_user.get("id"):
            user_id = current_user.get("id")
            if order.user_id != user_id:
                return {"success": False, "error": "Order not found"}

        # Check verification code
        print(f"DEBUG: Checking verification code '{verification_code}' against codes in DB: {order.verification_codes}")
        if not order.verification_codes or verification_code not in order.verification_codes:
            return {"success": False, "error": "Invalid verification code"}

        # Update order status
        order.status = "cancelled"

        # Remove used verification code
        order.verification_codes.remove(verification_code)

        # Flag the JSON column as modified (required for SQLAlchemy JSON columns)
        flag_modified(order, "verification_codes")

        db.commit()

        user_name = order.user.name if order.user else order.customer_name
        user_email = order.user.email if order.user else None

        print(f"DEBUG: Cancelled order {order_id} with verification code")

        return {
            "success": True,
            "message": f"Order {order_id} cancelled successfully",
            "refund_amount": order.total,
            "user_email": user_email,
            "user_name": user_name,
        }

    except Exception as e:
        print(f"Error cancelling order: {e}")
        return {"success": False, "error": "Database error"}

# ============================================================================
# Tools
# ============================================================================

tools = [
    {
        "type": "function",
        "function": {
            "name": "get_order_status",
            "description": "Get order status by order ID",
            "parameters": {
                "type": "object",
                "properties": {
                    "order_id": {"type": "string", "description": "Order ID (ORD-XXX)"}
                },
                "required": ["order_id"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "generate_cancellation_code",
            "description": "Generate verification code for cancellation",
            "parameters": {
                "type": "object",
                "properties": {"order_id": {"type": "string"}},
                "required": ["order_id"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "cancel_order_with_verification",
            "description": "Cancel order with verification code",
            "parameters": {
                "type": "object",
                "properties": {
                    "order_id": {"type": "string"},
                    "verification_code": {"type": "string"},
                },
                "required": ["order_id", "verification_code"],
            },
        },
    },
]

# ============================================================================
# System Prompt
# ============================================================================

SYSTEM_PROMPT = """You are a helpful customer support agent for an e-commerce company.

CANCELLATION PROCESS:
1. When user wants to cancel, call generate_cancellation_code(order_id)
2. Inform the user that a verification code has been generated
3. Wait for the user to provide the verification code
4. Call cancel_order_with_verification(order_id, code)

GUARDRAILS:
- ONLY answer order-related questions
- For non-order questions: "I can only assist with order-related queries."
- ALWAYS use verification for cancellations
- Be helpful and professional
"""

# ============================================================================
# Request/Response Models
# ============================================================================


class ChatRequest(BaseModel):
    message: str
    session_id: Optional[str] = None
    current_user: Optional[Dict[str, str]] = None  # User info if authenticated (e.g., from database)


class ApprovalRequest(BaseModel):
    id: str  # Approval ID (can be session_id)
    approved: bool
    userInput: Optional[str] = None
    current_user: Optional[Dict[str, str]] = None  # User info if available


# ============================================================================
# Agent Logic
# ============================================================================


async def process_agent_message(message: str, session_id: str, db: Session = None, current_user: Optional[Dict[str, str]] = None):
    """Process a message through the agent and emit events"""
    session = session_manager.get_session(session_id)
    if not session:
        await session_manager.emit_event(
            session_id, "error", {"message": "Session not found"}
        )
        return

    history = session["history"]

    # Add user message to history
    if message:
        history.append({"role": "user", "content": message})

    # Get current user info from session if not provided
    if not current_user and session.get("user_id"):
        current_user = {
            "id": session.get("user_id"),
            "name": session.get("user_name"),
            "email": session.get("user_email"),
        }

    # Add user context to system prompt if user info available
    system_prompt = SYSTEM_PROMPT
    if current_user:
        system_prompt += f"\n\nCURRENT USER CONTEXT:\n"
        system_prompt += f"- User ID: {current_user.get('id')}\n"
        system_prompt += f"- Name: {current_user.get('name')}\n"
        system_prompt += f"- Email: {current_user.get('email')}\n"

    try:
        while True:
            # Call the model
            response = client.chat.completions.create(
                model=MODEL,
                messages=[
                    {"role": "system", "content": system_prompt},
                    *history,
                ],
                tools=tools,
                tool_choice="auto",
                stream=False,
            )

            msg = response.choices[0].message

            if msg.tool_calls:
                # Add assistant message with tool calls to history
                history.append(
                    {
                        "role": "assistant",
                        "content": msg.content,
                        "tool_calls": [
                            {
                                "id": tc.id,
                                "type": tc.type,
                                "function": {
                                    "name": tc.function.name,
                                    "arguments": tc.function.arguments,
                                },
                            }
                            for tc in msg.tool_calls
                        ],
                    }
                )

                # Process each tool call
                for tool_call in msg.tool_calls:
                    func_name = tool_call.function.name
                    func_args = json.loads(tool_call.function.arguments)

                    print(f"DEBUG: Calling tool {func_name} with args {func_args}")

                    if func_name == "get_order_status":
                        result = get_order_status(db, **func_args, current_user=current_user)
                        print(f"DEBUG: get_order_status result: {result}")

                    elif func_name == "generate_cancellation_code":
                        result = generate_cancellation_code(db, **func_args, current_user=current_user)
                        print(f"DEBUG: generate_cancellation_code result: {result}")

                        # If approval required, emit approval event
                        if result.get("requires_approval"):
                            order_id = result["order_id"]

                            # Store pending approval
                            session["pending_approval"] = {
                                "order_id": order_id,
                                "code": result["code"],
                                "tool_call_id": tool_call.id,
                                "user_email": result.get("user_email"),
                                "user_name": result.get("user_name"),
                            }

                            # Emit approval event
                            await session_manager.emit_event(
                                session_id,
                                "approval",
                                {
                                    "id": session_id,
                                    "message": f"A verification code has been sent to your email address for order {order_id}. Please check your email (including spam/junk folder) and enter the 6-digit code below to confirm the cancellation.",
                                    "type": "input",
                                    "placeholder": "Enter verification code from email",
                                },
                            )
                            return  # Wait for approval

                    elif func_name == "cancel_order_with_verification":
                        result = cancel_order_with_verification(db, **func_args, current_user=current_user)

                    else:
                        result = {"error": "Unknown tool"}

                    # Add tool result to history
                    history.append(
                        {
                            "role": "tool",
                            "tool_call_id": tool_call.id,
                            "content": json.dumps(result),
                        }
                    )

            else:
                # No tool calls, emit message
                response_text = msg.content or ""

                print(f"DEBUG: Sending message event to session {session_id}: {response_text[:50]}...")
                await session_manager.emit_event(
                    session_id,
                    "message",
                    {
                        "id": str(uuid.uuid4()),
                        "role": "assistant",
                        "content": response_text,
                        "timestamp": None,
                    },
                )

                # Add to history
                history.append({"role": "assistant", "content": response_text})

                # Emit done event
                print(f"DEBUG: Sending done event to session {session_id}")
                await session_manager.emit_event(session_id, "done", {})
                break

    except Exception as e:
        print(f"DEBUG: Exception in process_agent_message: {e}")
        import traceback
        traceback.print_exc()
        await session_manager.emit_event(session_id, "error", {"message": str(e)})


async def handle_approval(
    session_id: str, approved: bool, user_input: Optional[str] = None, db: Session = None, current_user: Optional[Dict[str, str]] = None
):
    """Handle approval response from user"""
    print(f"DEBUG: handle_approval called - session_id: {session_id}, approved: {approved}, user_input: {user_input}")

    session = session_manager.get_session(session_id)
    if not session:
        print(f"DEBUG: Session not found - {session_id}")
        raise HTTPException(status_code=404, detail="Session not found")

    pending = session.get("pending_approval")
    if not pending:
        print(f"DEBUG: No pending approval for session {session_id}")
        await session_manager.emit_event(
            session_id, "error", {"message": "No pending approval"}
        )
        return

    history = session["history"]

    # Get current user info from session if not provided
    if not current_user and session.get("user_id"):
        current_user = {
            "id": session.get("user_id"),
            "name": session.get("user_name"),
            "email": session.get("user_email"),
        }

    if approved and user_input:
        # User approved - cancel the order
        result = {
            "success": True,
            "message": "User approved cancellation",
            "verification_code": user_input,
        }

        print(f"DEBUG: Executing cancellation for order {pending['order_id']} with code {user_input}")
        # Execute the cancellation
        cancellation_result = cancel_order_with_verification(
            db, pending["order_id"], user_input, current_user=current_user
        )
        print(f"DEBUG: Cancellation result: {cancellation_result}")

        if not cancellation_result.get("success"):
            print(f"DEBUG: Cancellation failed: {cancellation_result.get('error')}")

        # Add tool result
        history.append(
            {
                "role": "tool",
                "tool_call_id": pending["tool_call_id"],
                "content": json.dumps(cancellation_result),
            }
        )

        # Clear pending approval
        session["pending_approval"] = None

        print(f"DEBUG: Continuing agent processing for session {session_id}")
        # Continue processing
        await process_agent_message("", session_id, db, current_user)

    else:
        # User rejected
        result = {
            "success": False,
            "message": "User denied cancellation",
        }

        print(f"DEBUG: User rejected cancellation")
        # Add tool result
        history.append(
            {
                "role": "tool",
                "tool_call_id": pending["tool_call_id"],
                "content": json.dumps(result),
            }
        )

        # Clear pending approval
        session["pending_approval"] = None

        # Continue processing
        await process_agent_message("", session_id, db, current_user)


# ============================================================================
# SSE Stream Generator
# ============================================================================


async def event_stream(session_id: str) -> AsyncGenerator[str, None]:
    """Generate SSE events for a session"""
    print(f"DEBUG: New SSE stream for session {session_id}")

    # Check if session exists
    session = session_manager.get_session(session_id)
    if not session:
        print(f"DEBUG: Session {session_id} not found")
        yield f"data: {json.dumps({'type': 'error', 'data': {'message': 'Session not found'}})}\n\n"
        return

    # Get or create event queue for this session (don't create new queue on reconnect)
    queue = session_manager.get_event_queue(session_id)
    if not queue:
        print(f"DEBUG: No queue for session {session_id}, creating new one")
        queue = session_manager.get_or_create_event_queue(session_id)

    try:
        # First, drain any pending events that might be in the queue
        print(f"DEBUG: Starting event stream for session {session_id}, queue size: {queue.qsize()}")

        while True:
            # Wait for events
            print(f"DEBUG: Waiting for events in session {session_id}...")
            try:
                # Use a timeout to avoid hanging forever
                event = await asyncio.wait_for(queue.get(), timeout=30.0)
                print(f"DEBUG: Got event for session {session_id}: {event.get('type')}, data: {str(event.get('data', {}))[:100]}")
                yield f"data: {json.dumps(event)}\n\n"
            except asyncio.TimeoutError:
                # Send a keepalive comment to keep the connection alive
                yield ":keepalive\n\n"
    except asyncio.CancelledError:
        # Client disconnected - don't cleanup session or queue, it may reconnect
        print(f"DEBUG: SSE stream cancelled for session {session_id}")
        pass


# ============================================================================
# API Endpoints
# ============================================================================


@app.post("/api/chat")
async def chat(request: ChatRequest):
    """Handle chat messages"""
    # Get or create session with current_user info
    session_id = request.session_id or session_manager.create_session(request.current_user)

    # Create database session for background task
    async def process_with_db():
        db = SessionLocal()
        try:
            await process_agent_message(request.message, session_id, db, request.current_user)
        finally:
            db.close()

    # Start processing in the background
    asyncio.create_task(process_with_db())

    # Return session ID
    return {"session_id": session_id}


@app.get("/api/events")
async def events(session_id: str):
    """SSE endpoint for real-time events"""
    return StreamingResponse(
        event_stream(session_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
        },
    )


@app.post("/api/approval")
async def approval(request: ApprovalRequest):
    """Handle approval responses"""
    # Create database session for background task
    async def process_with_db():
        db = SessionLocal()
        try:
            await handle_approval(request.id, request.approved, request.userInput, db, request.current_user)
        except Exception as e:
            print(f"ERROR in approval processing: {e}")
            import traceback
            traceback.print_exc()
            await session_manager.emit_event(
                request.id, "error", {"message": str(e)}
            )
        finally:
            db.close()

    # Start processing in background (like chat endpoint)
    asyncio.create_task(process_with_db())

    return {"status": "ok"}


@app.get("/health")
async def health():
    """Health check endpoint"""
    return {"status": "ok"}


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "AI Agent Backend - Frontend Integration",
        "endpoints": {
            "POST /api/chat": "Send chat message",
            "GET /api/events": "SSE event stream",
            "POST /api/approval": "Handle approval",
            "GET /health": "Health check",
        },
    }


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
